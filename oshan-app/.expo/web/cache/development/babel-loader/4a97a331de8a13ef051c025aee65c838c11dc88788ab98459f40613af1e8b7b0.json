{"ast":null,"code":"\"use strict\";\n\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nvar _excluded = [\"testID\", \"labelText\", \"accessible\", \"accessibilityLabel\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport useLatestCallback from 'use-latest-callback';\nimport { TabBarIndicator } from \"./TabBarIndicator.js\";\nimport { TabBarItem } from \"./TabBarItem.js\";\nimport { useAnimatedValue } from \"./useAnimatedValue.js\";\nimport { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from \"react/jsx-runtime\";\nvar useNativeDriver = Platform.OS !== 'web';\nvar Separator = function Separator(_ref) {\n  var width = _ref.width;\n  return _jsx(View, {\n    style: {\n      width: width\n    }\n  });\n};\nvar getFlattenedTabWidth = function getFlattenedTabWidth(style) {\n  var tabStyle = StyleSheet.flatten(style);\n  return tabStyle == null ? void 0 : tabStyle.width;\n};\nvar getFlattenedPaddingStart = function getFlattenedPaddingStart(style) {\n  var flattenStyle = StyleSheet.flatten(style);\n  return flattenStyle ? flattenStyle.paddingLeft || flattenStyle.paddingStart || flattenStyle.paddingHorizontal || 0 : 0;\n};\nvar getFlattenedPaddingEnd = function getFlattenedPaddingEnd(style) {\n  var flattenStyle = StyleSheet.flatten(style);\n  return flattenStyle ? flattenStyle.paddingRight || flattenStyle.paddingEnd || flattenStyle.paddingHorizontal || 0 : 0;\n};\nvar convertPaddingPercentToSize = function convertPaddingPercentToSize(value, layout) {\n  switch (typeof value) {\n    case 'number':\n      return value;\n    case 'string':\n      if (value.endsWith('%')) {\n        var width = parseFloat(value);\n        if (Number.isFinite(width)) {\n          return layout.width * (width / 100);\n        }\n      }\n  }\n  return 0;\n};\nvar getComputedTabWidth = function getComputedTabWidth(index, layout, routes, scrollEnabled, tabWidths, flattenedWidth, flattenedPaddingStart, flattenedPaddingEnd, gap) {\n  if (flattenedWidth === 'auto') {\n    return tabWidths[routes[index].key] || 0;\n  }\n  switch (typeof flattenedWidth) {\n    case 'number':\n      return flattenedWidth;\n    case 'string':\n      if (flattenedWidth.endsWith('%')) {\n        var width = parseFloat(flattenedWidth);\n        if (Number.isFinite(width)) {\n          return layout.width * (width / 100);\n        }\n      }\n  }\n  if (scrollEnabled) {\n    return layout.width / 5 * 2;\n  }\n  var gapTotalWidth = (gap != null ? gap : 0) * (routes.length - 1);\n  var paddingTotalWidth = convertPaddingPercentToSize(flattenedPaddingStart, layout) + convertPaddingPercentToSize(flattenedPaddingEnd, layout);\n  return (layout.width - gapTotalWidth - paddingTotalWidth) / routes.length;\n};\nvar getMaxScrollDistance = function getMaxScrollDistance(tabBarWidth, layoutWidth) {\n  return tabBarWidth - layoutWidth;\n};\nvar getTranslateX = function getTranslateX(scrollAmount, maxScrollDistance, direction) {\n  return Animated.multiply(Platform.OS === 'android' && direction === 'rtl' ? Animated.add(maxScrollDistance, Animated.multiply(scrollAmount, -1)) : scrollAmount, direction === 'rtl' ? 1 : -1);\n};\nvar getTabBarWidth = function getTabBarWidth(_ref2) {\n  var navigationState = _ref2.navigationState,\n    layout = _ref2.layout,\n    gap = _ref2.gap,\n    scrollEnabled = _ref2.scrollEnabled,\n    flattenedTabWidth = _ref2.flattenedTabWidth,\n    flattenedPaddingStart = _ref2.flattenedPaddingStart,\n    flattenedPaddingEnd = _ref2.flattenedPaddingEnd,\n    tabWidths = _ref2.tabWidths;\n  var routes = navigationState.routes;\n  var paddingsWidth = Math.max(0, convertPaddingPercentToSize(flattenedPaddingStart, layout) + convertPaddingPercentToSize(flattenedPaddingEnd, layout));\n  return routes.reduce(function (acc, _, i) {\n    return acc + (i > 0 ? gap != null ? gap : 0 : 0) + getComputedTabWidth(i, layout, routes, scrollEnabled, tabWidths, flattenedTabWidth, flattenedPaddingStart, flattenedPaddingEnd, gap);\n  }, paddingsWidth);\n};\nvar normalizeScrollValue = function normalizeScrollValue(_ref3) {\n  var layout = _ref3.layout,\n    navigationState = _ref3.navigationState,\n    gap = _ref3.gap,\n    scrollEnabled = _ref3.scrollEnabled,\n    tabWidths = _ref3.tabWidths,\n    value = _ref3.value,\n    flattenedTabWidth = _ref3.flattenedTabWidth,\n    flattenedPaddingStart = _ref3.flattenedPaddingStart,\n    flattenedPaddingEnd = _ref3.flattenedPaddingEnd,\n    direction = _ref3.direction;\n  var tabBarWidth = getTabBarWidth({\n    layout: layout,\n    navigationState: navigationState,\n    tabWidths: tabWidths,\n    gap: gap,\n    scrollEnabled: scrollEnabled,\n    flattenedTabWidth: flattenedTabWidth,\n    flattenedPaddingStart: flattenedPaddingStart,\n    flattenedPaddingEnd: flattenedPaddingEnd\n  });\n  var maxDistance = getMaxScrollDistance(tabBarWidth, layout.width);\n  var scrollValue = Math.max(Math.min(value, maxDistance), 0);\n  if (Platform.OS === 'android' && direction === 'rtl') {\n    return maxDistance - scrollValue;\n  }\n  return scrollValue;\n};\nvar getScrollAmount = function getScrollAmount(_ref4) {\n  var layout = _ref4.layout,\n    navigationState = _ref4.navigationState,\n    gap = _ref4.gap,\n    scrollEnabled = _ref4.scrollEnabled,\n    flattenedTabWidth = _ref4.flattenedTabWidth,\n    tabWidths = _ref4.tabWidths,\n    flattenedPaddingStart = _ref4.flattenedPaddingStart,\n    flattenedPaddingEnd = _ref4.flattenedPaddingEnd,\n    direction = _ref4.direction;\n  var paddingInitial = direction === 'rtl' ? convertPaddingPercentToSize(flattenedPaddingEnd, layout) : convertPaddingPercentToSize(flattenedPaddingStart, layout);\n  var centerDistance = Array.from({\n    length: navigationState.index + 1\n  }).reduce(function (total, _, i) {\n    var tabWidth = getComputedTabWidth(i, layout, navigationState.routes, scrollEnabled, tabWidths, flattenedTabWidth, flattenedPaddingStart, flattenedPaddingEnd, gap);\n    return total + (i > 0 ? gap != null ? gap : 0 : 0) + (navigationState.index === i ? tabWidth / 2 : tabWidth);\n  }, paddingInitial);\n  var scrollAmount = centerDistance - layout.width / 2;\n  return normalizeScrollValue({\n    layout: layout,\n    navigationState: navigationState,\n    tabWidths: tabWidths,\n    value: scrollAmount,\n    gap: gap,\n    scrollEnabled: scrollEnabled,\n    flattenedTabWidth: flattenedTabWidth,\n    flattenedPaddingStart: flattenedPaddingStart,\n    flattenedPaddingEnd: flattenedPaddingEnd,\n    direction: direction\n  });\n};\nvar getLabelTextDefault = function getLabelTextDefault(_ref5) {\n  var route = _ref5.route;\n  return route.title;\n};\nvar getAccessibleDefault = function getAccessibleDefault(_ref6) {\n  var route = _ref6.route;\n  return typeof route.accessible !== 'undefined' ? route.accessible : true;\n};\nvar getAccessibilityLabelDefault = function getAccessibilityLabelDefault(_ref7) {\n  var route = _ref7.route;\n  return typeof route.accessibilityLabel === 'string' ? route.accessibilityLabel : typeof route.title === 'string' ? route.title : undefined;\n};\nvar renderIndicatorDefault = function renderIndicatorDefault(props) {\n  return _jsx(TabBarIndicator, _objectSpread({}, props));\n};\nvar getTestIdDefault = function getTestIdDefault(_ref8) {\n  var route = _ref8.route;\n  return route.testID;\n};\nvar MEASURE_PER_BATCH = 10;\nexport function TabBar(_ref9) {\n  var _ref9$renderIndicator = _ref9.renderIndicator,\n    renderIndicator = _ref9$renderIndicator === void 0 ? renderIndicatorDefault : _ref9$renderIndicator,\n    _ref9$gap = _ref9.gap,\n    gap = _ref9$gap === void 0 ? 0 : _ref9$gap,\n    scrollEnabled = _ref9.scrollEnabled,\n    jumpTo = _ref9.jumpTo,\n    navigationState = _ref9.navigationState,\n    position = _ref9.position,\n    activeColor = _ref9.activeColor,\n    bounces = _ref9.bounces,\n    contentContainerStyle = _ref9.contentContainerStyle,\n    inactiveColor = _ref9.inactiveColor,\n    indicatorContainerStyle = _ref9.indicatorContainerStyle,\n    indicatorStyle = _ref9.indicatorStyle,\n    onTabLongPress = _ref9.onTabLongPress,\n    onTabPress = _ref9.onTabPress,\n    pressColor = _ref9.pressColor,\n    pressOpacity = _ref9.pressOpacity,\n    _ref9$direction = _ref9.direction,\n    direction = _ref9$direction === void 0 ? I18nManager.getConstants().isRTL ? 'rtl' : 'ltr' : _ref9$direction,\n    renderTabBarItem = _ref9.renderTabBarItem,\n    style = _ref9.style,\n    tabStyle = _ref9.tabStyle,\n    propLayout = _ref9.layout,\n    testID = _ref9.testID,\n    android_ripple = _ref9.android_ripple,\n    options = _ref9.options;\n  var _React$useState = React.useState(propLayout != null ? propLayout : {\n      width: 0,\n      height: 0\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    layout = _React$useState2[0],\n    setLayout = _React$useState2[1];\n  var _React$useState3 = React.useState({}),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    tabWidths = _React$useState4[0],\n    setTabWidths = _React$useState4[1];\n  var flatListRef = React.useRef(null);\n  var isFirst = React.useRef(true);\n  var scrollAmount = useAnimatedValue(0);\n  var measuredTabWidths = React.useRef({});\n  var routes = navigationState.routes;\n  var flattenedTabWidth = getFlattenedTabWidth(tabStyle);\n  var isWidthDynamic = flattenedTabWidth === 'auto';\n  var flattenedPaddingEnd = getFlattenedPaddingEnd(contentContainerStyle);\n  var flattenedPaddingStart = getFlattenedPaddingStart(contentContainerStyle);\n  var scrollOffset = getScrollAmount({\n    layout: layout,\n    navigationState: navigationState,\n    tabWidths: tabWidths,\n    gap: gap,\n    scrollEnabled: scrollEnabled,\n    flattenedTabWidth: flattenedTabWidth,\n    flattenedPaddingStart: flattenedPaddingStart,\n    flattenedPaddingEnd: flattenedPaddingEnd,\n    direction: direction\n  });\n  var hasMeasuredTabWidths = Boolean(layout.width) && routes.slice(0, navigationState.index).every(function (r) {\n    return typeof tabWidths[r.key] === 'number';\n  });\n  React.useEffect(function () {\n    if (isFirst.current) {\n      isFirst.current = false;\n      return;\n    }\n    if (isWidthDynamic && !hasMeasuredTabWidths) {\n      return;\n    }\n    if (scrollEnabled) {\n      var _flatListRef$current;\n      (_flatListRef$current = flatListRef.current) == null ? void 0 : _flatListRef$current.scrollToOffset({\n        offset: scrollOffset,\n        animated: true\n      });\n    }\n  }, [hasMeasuredTabWidths, isWidthDynamic, scrollEnabled, scrollOffset]);\n  var handleLayout = function handleLayout(e) {\n    var _e$nativeEvent$layout = e.nativeEvent.layout,\n      height = _e$nativeEvent$layout.height,\n      width = _e$nativeEvent$layout.width;\n    setLayout(function (layout) {\n      return layout.width === width && layout.height === height ? layout : {\n        width: width,\n        height: height\n      };\n    });\n  };\n  var tabBarWidth = getTabBarWidth({\n    layout: layout,\n    navigationState: navigationState,\n    tabWidths: tabWidths,\n    gap: gap,\n    scrollEnabled: scrollEnabled,\n    flattenedTabWidth: flattenedTabWidth,\n    flattenedPaddingStart: flattenedPaddingStart,\n    flattenedPaddingEnd: flattenedPaddingEnd\n  });\n  var separatorsWidth = Math.max(0, routes.length - 1) * gap;\n  var paddingsWidth = Math.max(0, convertPaddingPercentToSize(flattenedPaddingStart, layout) + convertPaddingPercentToSize(flattenedPaddingEnd, layout));\n  var translateX = React.useMemo(function () {\n    return getTranslateX(scrollAmount, getMaxScrollDistance(tabBarWidth, layout.width), direction);\n  }, [direction, layout.width, scrollAmount, tabBarWidth]);\n  var renderItem = React.useCallback(function (_ref0) {\n    var _options$route$key;\n    var route = _ref0.item,\n      index = _ref0.index;\n    var _ref1 = (_options$route$key = options == null ? void 0 : options[route.key]) != null ? _options$route$key : {},\n      _ref1$testID = _ref1.testID,\n      testID = _ref1$testID === void 0 ? getTestIdDefault({\n        route: route\n      }) : _ref1$testID,\n      _ref1$labelText = _ref1.labelText,\n      labelText = _ref1$labelText === void 0 ? getLabelTextDefault({\n        route: route\n      }) : _ref1$labelText,\n      _ref1$accessible = _ref1.accessible,\n      accessible = _ref1$accessible === void 0 ? getAccessibleDefault({\n        route: route\n      }) : _ref1$accessible,\n      _ref1$accessibilityLa = _ref1.accessibilityLabel,\n      accessibilityLabel = _ref1$accessibilityLa === void 0 ? getAccessibilityLabelDefault({\n        route: route\n      }) : _ref1$accessibilityLa,\n      rest = _objectWithoutProperties(_ref1, _excluded);\n    var onLayout = isWidthDynamic ? function (e) {\n      measuredTabWidths.current[route.key] = e.nativeEvent.layout.width;\n      if (routes.length > MEASURE_PER_BATCH && index === MEASURE_PER_BATCH && routes.slice(0, MEASURE_PER_BATCH).every(function (r) {\n        return typeof measuredTabWidths.current[r.key] === 'number';\n      })) {\n        setTabWidths(_objectSpread({}, measuredTabWidths.current));\n      } else if (routes.every(function (r) {\n        return typeof measuredTabWidths.current[r.key] === 'number';\n      })) {\n        setTabWidths(_objectSpread({}, measuredTabWidths.current));\n      }\n    } : undefined;\n    var onPress = function onPress() {\n      var event = {\n        route: route,\n        defaultPrevented: false,\n        preventDefault: function preventDefault() {\n          event.defaultPrevented = true;\n        }\n      };\n      onTabPress == null ? void 0 : onTabPress(event);\n      if (event.defaultPrevented) {\n        return;\n      }\n      jumpTo(route.key);\n    };\n    var onLongPress = function onLongPress() {\n      return onTabLongPress == null ? void 0 : onTabLongPress({\n        route: route\n      });\n    };\n    var defaultTabWidth = !isWidthDynamic ? getComputedTabWidth(index, layout, routes, scrollEnabled, tabWidths, getFlattenedTabWidth(tabStyle), getFlattenedPaddingEnd(contentContainerStyle), getFlattenedPaddingStart(contentContainerStyle), gap) : undefined;\n    var props = _objectSpread(_objectSpread({}, rest), {}, {\n      position: position,\n      route: route,\n      navigationState: navigationState,\n      testID: testID,\n      labelText: labelText,\n      accessible: accessible,\n      accessibilityLabel: accessibilityLabel,\n      activeColor: activeColor,\n      inactiveColor: inactiveColor,\n      pressColor: pressColor,\n      pressOpacity: pressOpacity,\n      onLayout: onLayout,\n      onPress: onPress,\n      onLongPress: onLongPress,\n      style: tabStyle,\n      defaultTabWidth: defaultTabWidth,\n      android_ripple: android_ripple\n    });\n    return _jsxs(_Fragment, {\n      children: [gap > 0 && index > 0 ? _jsx(Separator, {\n        width: gap\n      }) : null, renderTabBarItem ? renderTabBarItem(_objectSpread({\n        key: route.key\n      }, props)) : _jsx(TabBarItem, _objectSpread({}, props), route.key)]\n    });\n  }, [position, navigationState, options, activeColor, inactiveColor, pressColor, pressOpacity, isWidthDynamic, tabStyle, layout, routes, scrollEnabled, tabWidths, contentContainerStyle, gap, android_ripple, renderTabBarItem, onTabPress, jumpTo, onTabLongPress]);\n  var keyExtractor = React.useCallback(function (item) {\n    return item.key;\n  }, []);\n  var contentContainerStyleMemoized = React.useMemo(function () {\n    return [styles.tabContent, scrollEnabled ? {\n      width: tabBarWidth\n    } : null, contentContainerStyle];\n  }, [contentContainerStyle, scrollEnabled, tabBarWidth]);\n  var handleScroll = React.useMemo(function () {\n    return Animated.event([{\n      nativeEvent: {\n        contentOffset: {\n          x: scrollAmount\n        }\n      }\n    }], {\n      useNativeDriver: useNativeDriver\n    });\n  }, [scrollAmount]);\n  var handleViewableItemsChanged = useLatestCallback(function (_ref10) {\n    var changed = _ref10.changed;\n    if (routes.length <= MEASURE_PER_BATCH) {\n      return;\n    }\n    var item = changed[changed.length - 1];\n    var index = (item == null ? void 0 : item.index) || 0;\n    if (item.isViewable && (index % 10 === 0 || index === navigationState.index || index === routes.length - 1)) {\n      setTabWidths(_objectSpread({}, measuredTabWidths.current));\n    }\n  });\n  return _jsxs(Animated.View, {\n    onLayout: handleLayout,\n    style: [styles.tabBar, style],\n    children: [_jsx(Animated.View, {\n      pointerEvents: \"none\",\n      style: [styles.indicatorContainer, scrollEnabled ? {\n        transform: [{\n          translateX: translateX\n        }]\n      } : null, scrollEnabled ? {\n        width: tabBarWidth\n      } : null, indicatorContainerStyle],\n      children: renderIndicator({\n        position: position,\n        layout: layout,\n        navigationState: navigationState,\n        jumpTo: jumpTo,\n        direction: direction,\n        width: isWidthDynamic ? 'auto' : Math.max(0, (tabBarWidth - separatorsWidth - paddingsWidth) / routes.length),\n        style: [indicatorStyle, {\n          start: flattenedPaddingStart,\n          end: flattenedPaddingEnd\n        }],\n        getTabWidth: function getTabWidth(i) {\n          return getComputedTabWidth(i, layout, routes, scrollEnabled, tabWidths, flattenedTabWidth, flattenedPaddingEnd, flattenedPaddingStart, gap);\n        },\n        gap: gap\n      })\n    }), _jsx(View, {\n      style: styles.scroll,\n      children: _jsx(Animated.FlatList, {\n        data: routes,\n        keyExtractor: keyExtractor,\n        horizontal: true,\n        role: \"tablist\",\n        keyboardShouldPersistTaps: \"handled\",\n        scrollEnabled: scrollEnabled,\n        bounces: bounces,\n        initialNumToRender: MEASURE_PER_BATCH,\n        onViewableItemsChanged: handleViewableItemsChanged,\n        alwaysBounceHorizontal: false,\n        scrollsToTop: false,\n        showsHorizontalScrollIndicator: false,\n        showsVerticalScrollIndicator: false,\n        automaticallyAdjustContentInsets: false,\n        overScrollMode: \"never\",\n        contentContainerStyle: contentContainerStyleMemoized,\n        scrollEventThrottle: 16,\n        renderItem: renderItem,\n        onScroll: handleScroll,\n        ref: flatListRef,\n        testID: testID\n      })\n    })]\n  });\n}\nvar styles = StyleSheet.create({\n  scroll: {\n    overflow: Platform.select({\n      default: 'scroll',\n      web: undefined\n    })\n  },\n  tabBar: _objectSpread({\n    zIndex: 1,\n    backgroundColor: '#2196f3',\n    elevation: 4\n  }, Platform.select({\n    default: {\n      shadowColor: 'black',\n      shadowOpacity: 0.1,\n      shadowRadius: StyleSheet.hairlineWidth,\n      shadowOffset: {\n        height: StyleSheet.hairlineWidth,\n        width: 0\n      }\n    },\n    web: {\n      boxShadow: '0 1px 1px rgba(0, 0, 0, 0.1)'\n    }\n  })),\n  tabContent: {\n    flexGrow: 1,\n    flexDirection: 'row',\n    flexWrap: 'nowrap'\n  },\n  indicatorContainer: {\n    position: 'absolute',\n    top: 0,\n    start: 0,\n    end: 0,\n    bottom: 0\n  }\n});","map":{"version":3,"names":["React","Animated","I18nManager","Platform","StyleSheet","View","useLatestCallback","TabBarIndicator","TabBarItem","useAnimatedValue","jsx","_jsx","Fragment","_Fragment","jsxs","_jsxs","useNativeDriver","OS","Separator","_ref","width","style","getFlattenedTabWidth","tabStyle","flatten","getFlattenedPaddingStart","flattenStyle","paddingLeft","paddingStart","paddingHorizontal","getFlattenedPaddingEnd","paddingRight","paddingEnd","convertPaddingPercentToSize","value","layout","endsWith","parseFloat","Number","isFinite","getComputedTabWidth","index","routes","scrollEnabled","tabWidths","flattenedWidth","flattenedPaddingStart","flattenedPaddingEnd","gap","key","gapTotalWidth","length","paddingTotalWidth","getMaxScrollDistance","tabBarWidth","layoutWidth","getTranslateX","scrollAmount","maxScrollDistance","direction","multiply","add","getTabBarWidth","_ref2","navigationState","flattenedTabWidth","paddingsWidth","Math","max","reduce","acc","_","i","normalizeScrollValue","_ref3","maxDistance","scrollValue","min","getScrollAmount","_ref4","paddingInitial","centerDistance","Array","from","total","tabWidth","getLabelTextDefault","_ref5","route","title","getAccessibleDefault","_ref6","accessible","getAccessibilityLabelDefault","_ref7","accessibilityLabel","undefined","renderIndicatorDefault","props","_objectSpread","getTestIdDefault","_ref8","testID","MEASURE_PER_BATCH","TabBar","_ref9","_ref9$renderIndicator","renderIndicator","_ref9$gap","jumpTo","position","activeColor","bounces","contentContainerStyle","inactiveColor","indicatorContainerStyle","indicatorStyle","onTabLongPress","onTabPress","pressColor","pressOpacity","_ref9$direction","getConstants","isRTL","renderTabBarItem","propLayout","android_ripple","options","_React$useState","useState","height","_React$useState2","_slicedToArray","setLayout","_React$useState3","_React$useState4","setTabWidths","flatListRef","useRef","isFirst","measuredTabWidths","isWidthDynamic","scrollOffset","hasMeasuredTabWidths","Boolean","slice","every","r","useEffect","current","_flatListRef$current","scrollToOffset","offset","animated","handleLayout","e","_e$nativeEvent$layout","nativeEvent","separatorsWidth","translateX","useMemo","renderItem","useCallback","_ref0","_options$route$key","item","_ref1","_ref1$testID","_ref1$labelText","labelText","_ref1$accessible","_ref1$accessibilityLa","rest","_objectWithoutProperties","_excluded","onLayout","onPress","event","defaultPrevented","preventDefault","onLongPress","defaultTabWidth","children","keyExtractor","contentContainerStyleMemoized","styles","tabContent","handleScroll","contentOffset","x","handleViewableItemsChanged","_ref10","changed","isViewable","tabBar","pointerEvents","indicatorContainer","transform","start","end","getTabWidth","scroll","FlatList","data","horizontal","role","keyboardShouldPersistTaps","initialNumToRender","onViewableItemsChanged","alwaysBounceHorizontal","scrollsToTop","showsHorizontalScrollIndicator","showsVerticalScrollIndicator","automaticallyAdjustContentInsets","overScrollMode","scrollEventThrottle","onScroll","ref","create","overflow","select","default","web","zIndex","backgroundColor","elevation","shadowColor","shadowOpacity","shadowRadius","hairlineWidth","shadowOffset","boxShadow","flexGrow","flexDirection","flexWrap","top","bottom"],"sources":["/Users/akhileshgogikar/Oshan/oshan-app/node_modules/react-native-tab-view/src/TabBar.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Animated,\n  type DimensionValue,\n  FlatList,\n  I18nManager,\n  type LayoutChangeEvent,\n  type ListRenderItemInfo,\n  Platform,\n  type PressableAndroidRippleConfig,\n  type StyleProp,\n  StyleSheet,\n  View,\n  type ViewStyle,\n  type ViewToken,\n} from 'react-native';\nimport useLatestCallback from 'use-latest-callback';\n\nimport {\n  type Props as IndicatorProps,\n  TabBarIndicator,\n} from './TabBarIndicator';\nimport { type Props as TabBarItemProps, TabBarItem } from './TabBarItem';\nimport type {\n  Event,\n  Layout,\n  LocaleDirection,\n  NavigationState,\n  Route,\n  Scene,\n  SceneRendererProps,\n  TabDescriptor,\n} from './types';\nimport { useAnimatedValue } from './useAnimatedValue';\n\nexport type Props<T extends Route> = SceneRendererProps & {\n  navigationState: NavigationState<T>;\n  scrollEnabled?: boolean;\n  bounces?: boolean;\n  activeColor?: string;\n  inactiveColor?: string;\n  pressColor?: string;\n  pressOpacity?: number;\n  options?: Record<string, TabDescriptor<T>>;\n  renderIndicator?: (props: IndicatorProps<T>) => React.ReactNode;\n  renderTabBarItem?: (\n    props: TabBarItemProps<T> & { key: string }\n  ) => React.ReactElement;\n  onTabPress?: (scene: Scene<T> & Event) => void;\n  onTabLongPress?: (scene: Scene<T>) => void;\n  tabStyle?: StyleProp<ViewStyle>;\n  indicatorStyle?: StyleProp<ViewStyle>;\n  indicatorContainerStyle?: StyleProp<ViewStyle>;\n  contentContainerStyle?: StyleProp<ViewStyle>;\n  style?: StyleProp<ViewStyle>;\n  direction?: LocaleDirection;\n  gap?: number;\n  testID?: string;\n  android_ripple?: PressableAndroidRippleConfig;\n};\n\nconst useNativeDriver = Platform.OS !== 'web';\n\nconst Separator = ({ width }: { width: number }) => {\n  return <View style={{ width }} />;\n};\n\nconst getFlattenedTabWidth = (style: StyleProp<ViewStyle>) => {\n  const tabStyle = StyleSheet.flatten(style);\n\n  return tabStyle?.width;\n};\n\nconst getFlattenedPaddingStart = (style: StyleProp<ViewStyle>) => {\n  const flattenStyle = StyleSheet.flatten(style);\n\n  return flattenStyle\n    ? flattenStyle.paddingLeft ||\n        flattenStyle.paddingStart ||\n        flattenStyle.paddingHorizontal ||\n        0\n    : 0;\n};\n\nconst getFlattenedPaddingEnd = (style: StyleProp<ViewStyle>) => {\n  const flattenStyle = StyleSheet.flatten(style);\n\n  return flattenStyle\n    ? flattenStyle.paddingRight ||\n        flattenStyle.paddingEnd ||\n        flattenStyle.paddingHorizontal ||\n        0\n    : 0;\n};\n\nconst convertPaddingPercentToSize = (\n  value: DimensionValue | undefined,\n  layout: Layout\n): number => {\n  switch (typeof value) {\n    case 'number':\n      return value;\n    case 'string':\n      if (value.endsWith('%')) {\n        const width = parseFloat(value);\n        if (Number.isFinite(width)) {\n          return layout.width * (width / 100);\n        }\n      }\n  }\n  return 0;\n};\n\nconst getComputedTabWidth = (\n  index: number,\n  layout: Layout,\n  routes: Route[],\n  scrollEnabled: boolean | undefined,\n  tabWidths: { [key: string]: number },\n  flattenedWidth: DimensionValue | undefined,\n  flattenedPaddingStart: DimensionValue | undefined,\n  flattenedPaddingEnd: DimensionValue | undefined,\n  gap?: number\n) => {\n  if (flattenedWidth === 'auto') {\n    return tabWidths[routes[index].key] || 0;\n  }\n\n  switch (typeof flattenedWidth) {\n    case 'number':\n      return flattenedWidth;\n    case 'string':\n      if (flattenedWidth.endsWith('%')) {\n        const width = parseFloat(flattenedWidth);\n        if (Number.isFinite(width)) {\n          return layout.width * (width / 100);\n        }\n      }\n  }\n\n  if (scrollEnabled) {\n    return (layout.width / 5) * 2;\n  }\n\n  const gapTotalWidth = (gap ?? 0) * (routes.length - 1);\n  const paddingTotalWidth =\n    convertPaddingPercentToSize(flattenedPaddingStart, layout) +\n    convertPaddingPercentToSize(flattenedPaddingEnd, layout);\n\n  return (layout.width - gapTotalWidth - paddingTotalWidth) / routes.length;\n};\n\nconst getMaxScrollDistance = (tabBarWidth: number, layoutWidth: number) =>\n  tabBarWidth - layoutWidth;\n\nconst getTranslateX = (\n  scrollAmount: Animated.Value,\n  maxScrollDistance: number,\n  direction: LocaleDirection\n) =>\n  Animated.multiply(\n    Platform.OS === 'android' && direction === 'rtl'\n      ? Animated.add(maxScrollDistance, Animated.multiply(scrollAmount, -1))\n      : scrollAmount,\n    direction === 'rtl' ? 1 : -1\n  );\n\nconst getTabBarWidth = <T extends Route>({\n  navigationState,\n  layout,\n  gap,\n  scrollEnabled,\n  flattenedTabWidth,\n  flattenedPaddingStart,\n  flattenedPaddingEnd,\n  tabWidths,\n}: Pick<Props<T>, 'navigationState' | 'gap' | 'layout' | 'scrollEnabled'> & {\n  tabWidths: Record<string, number>;\n  flattenedPaddingStart: DimensionValue | undefined;\n  flattenedPaddingEnd: DimensionValue | undefined;\n  flattenedTabWidth: DimensionValue | undefined;\n}) => {\n  const { routes } = navigationState;\n\n  const paddingsWidth = Math.max(\n    0,\n    convertPaddingPercentToSize(flattenedPaddingStart, layout) +\n      convertPaddingPercentToSize(flattenedPaddingEnd, layout)\n  );\n\n  return routes.reduce<number>(\n    (acc, _, i) =>\n      acc +\n      (i > 0 ? (gap ?? 0) : 0) +\n      getComputedTabWidth(\n        i,\n        layout,\n        routes,\n        scrollEnabled,\n        tabWidths,\n        flattenedTabWidth,\n        flattenedPaddingStart,\n        flattenedPaddingEnd,\n        gap\n      ),\n    paddingsWidth\n  );\n};\n\nconst normalizeScrollValue = <T extends Route>({\n  layout,\n  navigationState,\n  gap,\n  scrollEnabled,\n  tabWidths,\n  value,\n  flattenedTabWidth,\n  flattenedPaddingStart,\n  flattenedPaddingEnd,\n  direction,\n}: Pick<Props<T>, 'layout' | 'navigationState' | 'gap' | 'scrollEnabled'> & {\n  tabWidths: Record<string, number>;\n  value: number;\n  flattenedTabWidth: DimensionValue | undefined;\n  flattenedPaddingStart: DimensionValue | undefined;\n  flattenedPaddingEnd: DimensionValue | undefined;\n  direction: LocaleDirection;\n}) => {\n  const tabBarWidth = getTabBarWidth({\n    layout,\n    navigationState,\n    tabWidths,\n    gap,\n    scrollEnabled,\n    flattenedTabWidth,\n    flattenedPaddingStart,\n    flattenedPaddingEnd,\n  });\n  const maxDistance = getMaxScrollDistance(tabBarWidth, layout.width);\n  const scrollValue = Math.max(Math.min(value, maxDistance), 0);\n\n  if (Platform.OS === 'android' && direction === 'rtl') {\n    // On Android, scroll value is not applied in reverse in RTL\n    // so we need to manually adjust it to apply correct value\n    return maxDistance - scrollValue;\n  }\n\n  return scrollValue;\n};\n\nconst getScrollAmount = <T extends Route>({\n  layout,\n  navigationState,\n  gap,\n  scrollEnabled,\n  flattenedTabWidth,\n  tabWidths,\n  flattenedPaddingStart,\n  flattenedPaddingEnd,\n  direction,\n}: Pick<Props<T>, 'layout' | 'navigationState' | 'scrollEnabled' | 'gap'> & {\n  tabWidths: Record<string, number>;\n  flattenedTabWidth: DimensionValue | undefined;\n  flattenedPaddingStart: DimensionValue | undefined;\n  flattenedPaddingEnd: DimensionValue | undefined;\n  direction: LocaleDirection;\n}) => {\n  const paddingInitial =\n    direction === 'rtl'\n      ? convertPaddingPercentToSize(flattenedPaddingEnd, layout)\n      : convertPaddingPercentToSize(flattenedPaddingStart, layout);\n\n  const centerDistance = Array.from({\n    length: navigationState.index + 1,\n  }).reduce<number>((total, _, i) => {\n    const tabWidth = getComputedTabWidth(\n      i,\n      layout,\n      navigationState.routes,\n      scrollEnabled,\n      tabWidths,\n      flattenedTabWidth,\n      flattenedPaddingStart,\n      flattenedPaddingEnd,\n      gap\n    );\n\n    // To get the current index centered we adjust scroll amount by width of indexes\n    // 0 through (i - 1) and add half the width of current index i\n    return (\n      total +\n      (i > 0 ? (gap ?? 0) : 0) +\n      (navigationState.index === i ? tabWidth / 2 : tabWidth)\n    );\n  }, paddingInitial);\n\n  const scrollAmount = centerDistance - layout.width / 2;\n\n  return normalizeScrollValue({\n    layout,\n    navigationState,\n    tabWidths,\n    value: scrollAmount,\n    gap,\n    scrollEnabled,\n    flattenedTabWidth,\n    flattenedPaddingStart,\n    flattenedPaddingEnd,\n    direction,\n  });\n};\nconst getLabelTextDefault = ({ route }: Scene<Route>) => route.title;\n\nconst getAccessibleDefault = ({ route }: Scene<Route>) =>\n  typeof route.accessible !== 'undefined' ? route.accessible : true;\n\nconst getAccessibilityLabelDefault = ({ route }: Scene<Route>) =>\n  typeof route.accessibilityLabel === 'string'\n    ? route.accessibilityLabel\n    : typeof route.title === 'string'\n      ? route.title\n      : undefined;\n\nconst renderIndicatorDefault = (props: IndicatorProps<Route>) => (\n  <TabBarIndicator {...props} />\n);\n\nconst getTestIdDefault = ({ route }: Scene<Route>) => route.testID;\n\n// How many items measurements should we update per batch.\n// Defaults to 10, since that's whats FlatList is using in initialNumToRender.\nconst MEASURE_PER_BATCH = 10;\n\nexport function TabBar<T extends Route>({\n  renderIndicator = renderIndicatorDefault,\n  gap = 0,\n  scrollEnabled,\n  jumpTo,\n  navigationState,\n  position,\n  activeColor,\n  bounces,\n  contentContainerStyle,\n  inactiveColor,\n  indicatorContainerStyle,\n  indicatorStyle,\n  onTabLongPress,\n  onTabPress,\n  pressColor,\n  pressOpacity,\n  direction = I18nManager.getConstants().isRTL ? 'rtl' : 'ltr',\n  renderTabBarItem,\n  style,\n  tabStyle,\n  layout: propLayout,\n  testID,\n  android_ripple,\n  options,\n}: Props<T>) {\n  const [layout, setLayout] = React.useState<Layout>(\n    propLayout ?? { width: 0, height: 0 }\n  );\n  const [tabWidths, setTabWidths] = React.useState<Record<string, number>>({});\n  const flatListRef = React.useRef<FlatList | null>(null);\n  const isFirst = React.useRef(true);\n  const scrollAmount = useAnimatedValue(0);\n  const measuredTabWidths = React.useRef<Record<string, number>>({});\n  const { routes } = navigationState;\n  const flattenedTabWidth = getFlattenedTabWidth(tabStyle);\n  const isWidthDynamic = flattenedTabWidth === 'auto';\n  const flattenedPaddingEnd = getFlattenedPaddingEnd(contentContainerStyle);\n  const flattenedPaddingStart = getFlattenedPaddingStart(contentContainerStyle);\n  const scrollOffset = getScrollAmount({\n    layout,\n    navigationState,\n    tabWidths,\n    gap,\n    scrollEnabled,\n    flattenedTabWidth,\n    flattenedPaddingStart,\n    flattenedPaddingEnd,\n    direction,\n  });\n\n  const hasMeasuredTabWidths =\n    Boolean(layout.width) &&\n    routes\n      .slice(0, navigationState.index)\n      .every((r) => typeof tabWidths[r.key] === 'number');\n\n  React.useEffect(() => {\n    if (isFirst.current) {\n      isFirst.current = false;\n      return;\n    }\n\n    if (isWidthDynamic && !hasMeasuredTabWidths) {\n      return;\n    }\n\n    if (scrollEnabled) {\n      flatListRef.current?.scrollToOffset({\n        offset: scrollOffset,\n        animated: true,\n      });\n    }\n  }, [hasMeasuredTabWidths, isWidthDynamic, scrollEnabled, scrollOffset]);\n\n  const handleLayout = (e: LayoutChangeEvent) => {\n    const { height, width } = e.nativeEvent.layout;\n\n    setLayout((layout) =>\n      layout.width === width && layout.height === height\n        ? layout\n        : { width, height }\n    );\n  };\n\n  const tabBarWidth = getTabBarWidth({\n    layout,\n    navigationState,\n    tabWidths,\n    gap,\n    scrollEnabled,\n    flattenedTabWidth,\n    flattenedPaddingStart,\n    flattenedPaddingEnd,\n  });\n\n  const separatorsWidth = Math.max(0, routes.length - 1) * gap;\n  const paddingsWidth = Math.max(\n    0,\n    convertPaddingPercentToSize(flattenedPaddingStart, layout) +\n      convertPaddingPercentToSize(flattenedPaddingEnd, layout)\n  );\n\n  const translateX = React.useMemo(\n    () =>\n      getTranslateX(\n        scrollAmount,\n        getMaxScrollDistance(tabBarWidth, layout.width),\n        direction\n      ),\n    [direction, layout.width, scrollAmount, tabBarWidth]\n  );\n\n  const renderItem = React.useCallback(\n    ({ item: route, index }: ListRenderItemInfo<T>) => {\n      const {\n        testID = getTestIdDefault({ route }),\n        labelText = getLabelTextDefault({ route }),\n        accessible = getAccessibleDefault({ route }),\n        accessibilityLabel = getAccessibilityLabelDefault({ route }),\n        ...rest\n      } = options?.[route.key] ?? {};\n\n      const onLayout = isWidthDynamic\n        ? (e: LayoutChangeEvent) => {\n            measuredTabWidths.current[route.key] = e.nativeEvent.layout.width;\n\n            // When we have measured widths for all of the tabs, we should updates the state\n            // We avoid doing separate setState for each layout since it triggers multiple renders and slows down app\n            // If we have more than 10 routes divide updating tabWidths into multiple batches. Here we update only first batch of 10 items.\n            if (\n              routes.length > MEASURE_PER_BATCH &&\n              index === MEASURE_PER_BATCH &&\n              routes\n                .slice(0, MEASURE_PER_BATCH)\n                .every(\n                  (r) => typeof measuredTabWidths.current[r.key] === 'number'\n                )\n            ) {\n              setTabWidths({ ...measuredTabWidths.current });\n            } else if (\n              routes.every(\n                (r) => typeof measuredTabWidths.current[r.key] === 'number'\n              )\n            ) {\n              // When we have measured widths for all of the tabs, we should updates the state\n              // We avoid doing separate setState for each layout since it triggers multiple renders and slows down app\n              setTabWidths({ ...measuredTabWidths.current });\n            }\n          }\n        : undefined;\n\n      const onPress = () => {\n        const event: Scene<T> & Event = {\n          route,\n          defaultPrevented: false,\n          preventDefault: () => {\n            event.defaultPrevented = true;\n          },\n        };\n\n        onTabPress?.(event);\n\n        if (event.defaultPrevented) {\n          return;\n        }\n\n        jumpTo(route.key);\n      };\n\n      const onLongPress = () => onTabLongPress?.({ route });\n\n      // Calculate the default width for tab for FlatList to work\n      const defaultTabWidth = !isWidthDynamic\n        ? getComputedTabWidth(\n            index,\n            layout,\n            routes,\n            scrollEnabled,\n            tabWidths,\n            getFlattenedTabWidth(tabStyle),\n            getFlattenedPaddingEnd(contentContainerStyle),\n            getFlattenedPaddingStart(contentContainerStyle),\n            gap\n          )\n        : undefined;\n\n      const props = {\n        ...rest,\n        position,\n        route,\n        navigationState,\n        testID,\n        labelText,\n        accessible,\n        accessibilityLabel,\n        activeColor,\n        inactiveColor,\n        pressColor,\n        pressOpacity,\n        onLayout,\n        onPress,\n        onLongPress,\n        style: tabStyle,\n        defaultTabWidth,\n        android_ripple,\n      } satisfies TabBarItemProps<T>;\n\n      return (\n        <>\n          {gap > 0 && index > 0 ? <Separator width={gap} /> : null}\n          {renderTabBarItem ? (\n            renderTabBarItem({ key: route.key, ...props })\n          ) : (\n            <TabBarItem key={route.key} {...props} />\n          )}\n        </>\n      );\n    },\n    [\n      position,\n      navigationState,\n      options,\n      activeColor,\n      inactiveColor,\n      pressColor,\n      pressOpacity,\n      isWidthDynamic,\n      tabStyle,\n      layout,\n      routes,\n      scrollEnabled,\n      tabWidths,\n      contentContainerStyle,\n      gap,\n      android_ripple,\n      renderTabBarItem,\n      onTabPress,\n      jumpTo,\n      onTabLongPress,\n    ]\n  );\n\n  const keyExtractor = React.useCallback((item: T) => item.key, []);\n\n  const contentContainerStyleMemoized = React.useMemo(\n    () => [\n      styles.tabContent,\n      scrollEnabled ? { width: tabBarWidth } : null,\n      contentContainerStyle,\n    ],\n    [contentContainerStyle, scrollEnabled, tabBarWidth]\n  );\n\n  const handleScroll = React.useMemo(\n    () =>\n      Animated.event(\n        [\n          {\n            nativeEvent: {\n              contentOffset: { x: scrollAmount },\n            },\n          },\n        ],\n        { useNativeDriver }\n      ),\n    [scrollAmount]\n  );\n\n  const handleViewableItemsChanged = useLatestCallback(\n    ({ changed }: { changed: ViewToken[] }) => {\n      if (routes.length <= MEASURE_PER_BATCH) {\n        return;\n      }\n      // Get next vievable item\n      const item = changed[changed.length - 1];\n      const index = item?.index || 0;\n      if (\n        item.isViewable &&\n        (index % 10 === 0 ||\n          index === navigationState.index ||\n          index === routes.length - 1)\n      ) {\n        setTabWidths({ ...measuredTabWidths.current });\n      }\n    }\n  );\n\n  return (\n    <Animated.View onLayout={handleLayout} style={[styles.tabBar, style]}>\n      <Animated.View\n        pointerEvents=\"none\"\n        style={[\n          styles.indicatorContainer,\n          scrollEnabled ? { transform: [{ translateX }] as any } : null,\n          scrollEnabled ? { width: tabBarWidth } : null,\n          indicatorContainerStyle,\n        ]}\n      >\n        {renderIndicator({\n          position,\n          layout,\n          navigationState,\n          jumpTo,\n          direction,\n          width: isWidthDynamic\n            ? 'auto'\n            : Math.max(\n                0,\n                (tabBarWidth - separatorsWidth - paddingsWidth) / routes.length\n              ),\n          style: [\n            indicatorStyle,\n            { start: flattenedPaddingStart, end: flattenedPaddingEnd },\n          ],\n          getTabWidth: (i: number) =>\n            getComputedTabWidth(\n              i,\n              layout,\n              routes,\n              scrollEnabled,\n              tabWidths,\n              flattenedTabWidth,\n              flattenedPaddingEnd,\n              flattenedPaddingStart,\n              gap\n            ),\n          gap,\n        })}\n      </Animated.View>\n      <View style={styles.scroll}>\n        <Animated.FlatList\n          data={routes as Animated.WithAnimatedValue<T>[]}\n          keyExtractor={keyExtractor}\n          horizontal\n          role=\"tablist\"\n          keyboardShouldPersistTaps=\"handled\"\n          scrollEnabled={scrollEnabled}\n          bounces={bounces}\n          initialNumToRender={MEASURE_PER_BATCH}\n          onViewableItemsChanged={handleViewableItemsChanged}\n          alwaysBounceHorizontal={false}\n          scrollsToTop={false}\n          showsHorizontalScrollIndicator={false}\n          showsVerticalScrollIndicator={false}\n          automaticallyAdjustContentInsets={false}\n          overScrollMode=\"never\"\n          contentContainerStyle={contentContainerStyleMemoized}\n          scrollEventThrottle={16}\n          renderItem={renderItem}\n          onScroll={handleScroll}\n          ref={flatListRef}\n          testID={testID}\n        />\n      </View>\n    </Animated.View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  scroll: {\n    overflow: Platform.select({ default: 'scroll', web: undefined }),\n  },\n  tabBar: {\n    zIndex: 1,\n    backgroundColor: '#2196f3',\n    elevation: 4,\n    ...Platform.select({\n      default: {\n        shadowColor: 'black',\n        shadowOpacity: 0.1,\n        shadowRadius: StyleSheet.hairlineWidth,\n        shadowOffset: {\n          height: StyleSheet.hairlineWidth,\n          width: 0,\n        },\n      },\n      web: {\n        boxShadow: '0 1px 1px rgba(0, 0, 0, 0.1)',\n      },\n    }),\n  },\n  tabContent: {\n    flexGrow: 1,\n    flexDirection: 'row',\n    flexWrap: 'nowrap',\n  },\n  indicatorContainer: {\n    position: 'absolute',\n    top: 0,\n    start: 0,\n    end: 0,\n    bottom: 0,\n  },\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}